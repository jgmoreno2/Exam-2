	This problem asks that we take a positive integer and return the minimum amount of perfect squares that can add up to it. Looking deeper at this problem, we see that we need to move through the perfect square numbers less than or equal to the target and add them to a sum to see which possible permutation yields the lowest amount of numbers within the sum.
	
	I decided to stick with the idea that the sums of squares can be easily accessed and utilized if they're stored in a matrix, such that the item at row m and column n is the sum of the mth and nth squares. I decided to move through all squares less than n, appending them to a squares list. Then, I populated our matrix by moving through each row i and column j, setting the element in question as the sum of the ith and jth square. Afterwards, the actual work begins with looping an algorithm until n is depleted. The algorithm moves through the matrix, essentially bombarding n with base cases to try and shorten the amount of elements that are added to our sum. If these base cases are not hit, the algorithm finds the highest value in the matrix that is still under n to subtract from n, whilst adding to the count the number of items that are accessed for this.
	
	Following IDEAL, I first identified the problem as needing to take a number and return the amount of squares less than or equal to it that are required to add up to it. I then defined the problem recursively as needing to move through a list of square less than or equal to a target, adding numbers to a sum that will eventually reach n, keeping track of how many numbers are used to get there. Then, we must return the smallest of those. I then moved to explore solutions and found that using a matrix to store the values of squares summed together and an array that stores the squares themselves, I was able to keep close track of which elements needed to be added when to eventually reach our target with the minimum amount of additions. I then implemented this with an algorithm that continuously searches the matrix and array for values that are equal to, or as close as possible to (without exceeding) our target. The algorithm then adds them and repeats until a base case is found where either only one square is needed, a sum of two squares, or a sum of three squares. Looking back on this algorithm, I strongly believe that there is a better way to implement this. The reason I put in such an amount of base cases is because I felt that my algorithm wasn't covering ground the way I wanted it to, so I decided to push for a more greedy algorithm that gets the job done "close enough." Although I received the right answers here, I believe that larger values of n may present incorrect (but close) results.
