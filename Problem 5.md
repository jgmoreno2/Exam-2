	This problem asks that we take a list of number pairs and determine the maximum amount of pairs we can link together such that the second element of the first pair is less than the first element of the second pair. In other words, we must move through a list of pairs, linking together whichever ones fit the criteria, and return the maximum length of a linked pair list. 
	
	To solve this dynamically, I thought it may be beneficial to store the possibilities of linking in a square matrix where each row i, and column j element implies that the pair at index i can precede the pair at index j in a chain. My algorithm creates essentially an adjacency matrix for a directed graph then completes itself by adding weights to each edge via adding weights of continuous paths and setting them as the element at the origin.
	
	Following IDEAL, I identified the problem as being asked to find the maximum amount of given pairs that can be linked together with the requirement that the first pair's second value must be less than the second pair's first value. I then defined it recursively by stating that we must move through a list of pairs, linking together whichever ones fit the criteria, and return the maximum length of a linked pair list. Then, after exploring solutions, I found that I could create a weighted adjacency matrix that is first populated with a 1 if there is a possible link between row i and column j. Then, the weights are added by moving through the matrix again and adding the weights of a pair's destination to the origin. Afterwards, the maximum weight is evaluated and returned. I implemented this by creating a set of for loops to populate the matrix with 1's where needed. Then another set of nested for loops that, when a 1 is found, add the maximum value from the destination's row to the value stored in the source. As this happens, the new values are compared to a maximum value that is updated and returned when necessary. Looking back on this program, I believe this could have been more efficient. I would have liked to complete all processes within the same nested loops, rather than creating two separate occurrences. However, I produced optimal answers and believe my algorithm is effective nonetheless.
