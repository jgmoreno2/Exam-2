	This problem asks that we take a square matrix of integers and determine the sum of the minimum falling path. This means, we start at a certain index in row 0 and move one row down, switching right or left by 1 index in the new row. Once the bottom is reached, a sum of all the elements crossed is gathered. The path with the least sum at the bottom is the one used.
	
	The dynamic programming approach I'd like to implement is creating a matrix of identical size that stores the top row values in the top row, then, moves down row by row, setting each index as the corresponding index in the original matrix added to the minimum of index + 1 and index - 1 in the above row. This technique stores sums as it moves downward to complete this process in linear time.
	
	I prefer working with the IDEAL framework because of how abstract it is. I prefer not to follow strict guidelines like the ones found in Duke's 7. To start working with IDEAL, I had to identify the problem. The problem is that I need to find the smallest sum at the bottom of a matrix that can be obtained by adding previous, adjacent indexes in a square matrix. I then decided to define the problem recursively by stating how I needed to move row by row, swaying to the right or left once, to eventually reach a base case (bottom row). During these movements I needed to gather a sum of all elements crossed and determine the minimum cost path. I then explored dynamic solutions, as per the instructions. By tracing the properties of how a matrix can form paths between rows and adjacent indexes, I found that each index can be a sum of the path that ends above and to the left or above and to the right. Therefore, I decided to find a solution that works on taking advantage of that. I implemented this by creating an identical size matrix to the original, such that each index was the sum of the current index and the minimum of the sums of paths that end above and to the left or right. Afterwards, I looked back on how the program worked and realized that it worked very well for this specific problem. Rather than going through every possible permutation of sums, it went through a smaller portion by adding things as they went along.
