	This problem asks that we take a string as input to output the number of palindromic substrings that can be obtained from it. To be more precise, a palindrome is a word that can be read the same backwards as it can be forwards. This means, we should take a string of characters, move through them index by index, and add to a counter the amount of palindromes there are that exist behind it, inclusive.
	
	To solve with dynamic programming, we may be able to find a way to store substrings that could potentially create palindromes, and count the ones that end up doing so. What I'd like to try is creating a 2-D array where the first dimension contains the characters at each index, while the second dimension contains the set of all substrings that come before the specified index, including the character in question. As the program moves along, it checks each new word added for a palindrome by adding one to the count for each word that has an equal value when one half of the word is reversed and compared to the other.
	
	Describing the design process in terms of IDEAL, I first identified the problem as needing to find the number of substrings in the word, such that one half of the substring in reverse is equal to the other, not including any middle character for odd sized strings. I then defined the problem recursively by stating that I needed to move character by character, checking each substring behind (and including) the specified one, adding all palindromes to a count that would eventually be returned once the end of the string is reached. Then, I moved on to explore solutions and found that we could use a 2-D array that contains lists for each character's possible substrings including and to the left of it. I implemented this by writing a loop that moves through each character, creating a list, adding itself + all words in above character's list, then checking for palindromes and adding if necessary. In looking back on my solution and how it reacted to test cases, I noticed that it worked quite well. I realized that by creating a list that essentially adds on to itself by using its previous values, I efficiently found all possible substrings for each character that could then be evaluated for palindromes.
